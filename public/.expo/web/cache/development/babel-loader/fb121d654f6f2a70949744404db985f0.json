{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport React, { Component } from 'react';\nimport InteractionManager from \"react-native-web/dist/exports/InteractionManager\";\nimport PropTypes from 'prop-types';\nimport { Path } from 'react-native-svg';\nimport * as interpolate from 'd3-interpolate-path';\n\nvar AnimatedPath = function (_Component) {\n  _inherits(AnimatedPath, _Component);\n\n  var _super = _createSuper(AnimatedPath);\n\n  function AnimatedPath(props) {\n    var _this;\n\n    _classCallCheck(this, AnimatedPath);\n\n    _this = _super.call(this, props);\n    _this.state = {\n      d: props.d\n    };\n    return _this;\n  }\n\n  _createClass(AnimatedPath, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(props) {\n      var _this$props = this.props,\n          newD = _this$props.d,\n          animate = _this$props.animate;\n      var oldD = props.d;\n      this.newD = newD;\n\n      if (newD === oldD) {\n        return;\n      }\n\n      if (!animate || newD === null || oldD === null) {\n        return;\n      }\n\n      this.newD = newD;\n      this.interpolator = interpolate.interpolatePath(oldD, newD);\n\n      this._animate();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      cancelAnimationFrame(this.animation);\n\n      this._clearInteraction();\n    }\n  }, {\n    key: \"_animate\",\n    value: function _animate(start) {\n      var _this2 = this;\n\n      cancelAnimationFrame(this.animation);\n      this.animation = requestAnimationFrame(function (timestamp) {\n        if (!start) {\n          _this2._clearInteraction();\n\n          _this2.handle = InteractionManager.createInteractionHandle();\n          start = timestamp;\n        }\n\n        var delta = (timestamp - start) / _this2.props.animationDuration;\n\n        if (delta > 1) {\n          _this2.component.setNativeProps({\n            d: _this2.newD\n          });\n\n          _this2._clearInteraction();\n\n          return;\n        }\n\n        var d = _this2.interpolator(delta);\n\n        _this2.component.setNativeProps({\n          d: d\n        });\n\n        _this2.setState(_this2.state, function () {\n          _this2._animate(start);\n        });\n      });\n    }\n  }, {\n    key: \"_clearInteraction\",\n    value: function _clearInteraction() {\n      if (this.handle) {\n        InteractionManager.clearInteractionHandle(this.handle);\n        this.handle = null;\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      return React.createElement(Path, _extends({\n        ref: function ref(_ref) {\n          return _this3.component = _ref;\n        }\n      }, this.props, {\n        d: this.props.animate ? this.state.d : this.props.d\n      }));\n    }\n  }]);\n\n  return AnimatedPath;\n}(Component);\n\nAnimatedPath.propTypes = _objectSpread({\n  animate: PropTypes.bool,\n  animationDuration: PropTypes.number,\n  renderPlaceholder: PropTypes.func\n}, Path.propTypes);\nAnimatedPath.defaultProps = {\n  animate: false,\n  animationDuration: 300,\n  renderPlaceholder: function renderPlaceholder() {\n    return null;\n  }\n};\nexport default AnimatedPath;","map":{"version":3,"sources":["animated-path.js"],"names":["constructor","d","props","componentDidUpdate","animate","oldD","newD","interpolate","componentWillUnmount","cancelAnimationFrame","_animate","requestAnimationFrame","timestamp","InteractionManager","start","delta","_clearInteraction","render","ref","AnimatedPath","PropTypes","animationDuration","renderPlaceholder","func","Path"],"mappings":"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","sourcesContent":["import React, { Component } from 'react'\nimport { InteractionManager } from 'react-native'\nimport PropTypes from 'prop-types'\nimport { Path } from 'react-native-svg'\nimport * as interpolate from 'd3-interpolate-path'\n\nclass AnimatedPath extends Component {\n    constructor(props) {\n        super(props)\n\n        this.state = { d: props.d }\n    }\n\n    componentDidUpdate(props) {\n        const { d: newD, animate } = this.props\n        const { d: oldD } = props\n\n        this.newD = newD\n\n        if (newD === oldD) {\n            return\n        }\n\n        if (!animate || newD === null || oldD === null) {\n            return\n        }\n\n        this.newD = newD\n        this.interpolator = interpolate.interpolatePath(oldD, newD)\n\n        this._animate()\n    }\n\n    componentWillUnmount() {\n        cancelAnimationFrame(this.animation)\n        this._clearInteraction()\n    }\n\n    _animate(start) {\n        cancelAnimationFrame(this.animation)\n        this.animation = requestAnimationFrame((timestamp) => {\n            if (!start) {\n                this._clearInteraction()\n                this.handle = InteractionManager.createInteractionHandle()\n\n                start = timestamp\n            }\n\n            // Get the delta on how far long in our animation we are.\n            const delta = (timestamp - start) / this.props.animationDuration\n\n            // If we're above 1 then our animation should be complete.\n            if (delta > 1) {\n                // Just to be safe set our final value to the new graph path.\n                this.component.setNativeProps({ d: this.newD })\n                // Stop our animation loop.\n                this._clearInteraction()\n                return\n            }\n\n            const d = this.interpolator(delta)\n            this.component.setNativeProps({ d })\n            // console.log(this.interpolator)\n            // this.tween && console.log(this.tween.tween(delta))\n            // Tween the SVG path value according to what delta we're currently at.\n\n            // Update our state with the new tween value and then jump back into\n            // this loop.\n            this.setState(this.state, () => {\n                this._animate(start)\n            })\n        })\n    }\n\n    _clearInteraction() {\n        if (this.handle) {\n            InteractionManager.clearInteractionHandle(this.handle)\n            this.handle = null\n        }\n    }\n\n    render() {\n        return (\n            <Path\n                ref={(ref) => (this.component = ref)}\n                {...this.props}\n                d={this.props.animate ? this.state.d : this.props.d}\n            />\n        )\n    }\n}\n\nAnimatedPath.propTypes = {\n    animate: PropTypes.bool,\n    animationDuration: PropTypes.number,\n    renderPlaceholder: PropTypes.func,\n    ...Path.propTypes,\n}\n\nAnimatedPath.defaultProps = {\n    animate: false,\n    animationDuration: 300,\n    renderPlaceholder: () => null,\n}\n\nexport default AnimatedPath\n"]},"metadata":{},"sourceType":"module"}