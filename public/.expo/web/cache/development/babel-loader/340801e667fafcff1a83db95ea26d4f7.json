{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport * as array from 'd3-array';\nimport * as scale from 'd3-scale';\nimport * as shape from 'd3-shape';\nimport PropTypes from 'prop-types';\nimport React, { PureComponent } from 'react';\nimport View from \"react-native-web/dist/exports/View\";\nimport Svg from 'react-native-svg';\nimport Path from \"../animated-path\";\n\nvar BarChart = function (_PureComponent) {\n  _inherits(BarChart, _PureComponent);\n\n  var _super = _createSuper(BarChart);\n\n  function BarChart() {\n    var _this;\n\n    _classCallCheck(this, BarChart);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      width: 0,\n      height: 0\n    });\n\n    return _this;\n  }\n\n  _createClass(BarChart, [{\n    key: \"_onLayout\",\n    value: function _onLayout(event) {\n      var _event$nativeEvent$la = event.nativeEvent.layout,\n          height = _event$nativeEvent$la.height,\n          width = _event$nativeEvent$la.width;\n      this.setState({\n        height: height,\n        width: width\n      });\n    }\n  }, {\n    key: \"calcXScale\",\n    value: function calcXScale(domain) {\n      var data = this.props.data;\n      var _this$props = this.props,\n          horizontal = _this$props.horizontal,\n          _this$props$contentIn = _this$props.contentInset,\n          _this$props$contentIn2 = _this$props$contentIn.left,\n          left = _this$props$contentIn2 === void 0 ? 0 : _this$props$contentIn2,\n          _this$props$contentIn3 = _this$props$contentIn.right,\n          right = _this$props$contentIn3 === void 0 ? 0 : _this$props$contentIn3,\n          spacingInner = _this$props.spacingInner,\n          spacingOuter = _this$props.spacingOuter;\n      var width = this.state.width;\n\n      if (horizontal) {\n        return scale.scaleLinear().domain(domain).range([left, width - right]);\n      }\n\n      return scale.scaleBand().domain(data.map(function (_, index) {\n        return index;\n      })).range([left, width - right]).paddingInner([spacingInner]).paddingOuter([spacingOuter]);\n    }\n  }, {\n    key: \"calcYScale\",\n    value: function calcYScale(domain) {\n      var data = this.props.data;\n      var _this$props2 = this.props,\n          horizontal = _this$props2.horizontal,\n          _this$props2$contentI = _this$props2.contentInset,\n          _this$props2$contentI2 = _this$props2$contentI.top,\n          top = _this$props2$contentI2 === void 0 ? 0 : _this$props2$contentI2,\n          _this$props2$contentI3 = _this$props2$contentI.bottom,\n          bottom = _this$props2$contentI3 === void 0 ? 0 : _this$props2$contentI3,\n          spacingInner = _this$props2.spacingInner,\n          spacingOuter = _this$props2.spacingOuter;\n      var height = this.state.height;\n\n      if (horizontal) {\n        return scale.scaleBand().domain(data.map(function (_, index) {\n          return index;\n        })).range([top, height - bottom]).paddingInner([spacingInner]).paddingOuter([spacingOuter]);\n      }\n\n      return scale.scaleLinear().domain(domain).range([height - bottom, top]);\n    }\n  }, {\n    key: \"calcAreas\",\n    value: function calcAreas(x, y, series) {\n      var _this$props3 = this.props,\n          horizontal = _this$props3.horizontal,\n          colors = _this$props3.colors,\n          keys = _this$props3.keys;\n\n      if (horizontal) {\n        return array.merge(series.map(function (serie, keyIndex) {\n          return serie.map(function (entry, entryIndex) {\n            var path = shape.area().x0(function (d) {\n              return x(d[0]);\n            }).x1(function (d) {\n              return x(d[1]);\n            }).y(function (d, _index) {\n              return _index === 0 ? y(entryIndex) : y(entryIndex) + y.bandwidth();\n            }).defined(function (d) {\n              return !isNaN(d[0]) && !isNaN(d[1]);\n            })([entry, entry]);\n            return {\n              path: path,\n              color: colors[keyIndex],\n              key: keys[keyIndex]\n            };\n          });\n        }));\n      }\n\n      return array.merge(series.map(function (serie, keyIndex) {\n        return serie.map(function (entry, entryIndex) {\n          var path = shape.area().y0(function (d) {\n            return y(d[0]);\n          }).y1(function (d) {\n            return y(d[1]);\n          }).x(function (d, _index) {\n            return _index === 0 ? x(entryIndex) : x(entryIndex) + x.bandwidth();\n          }).defined(function (d) {\n            return !isNaN(d[0]) && !isNaN(d[1]);\n          })([entry, entry]);\n          return {\n            path: path,\n            color: colors[keyIndex],\n            key: keys[keyIndex]\n          };\n        });\n      }));\n    }\n  }, {\n    key: \"calcExtent\",\n    value: function calcExtent(values) {\n      var _this$props4 = this.props,\n          gridMax = _this$props4.gridMax,\n          gridMin = _this$props4.gridMin;\n      return array.extent([].concat(_toConsumableArray(values), [gridMin, gridMax]));\n    }\n  }, {\n    key: \"calcIndexes\",\n    value: function calcIndexes(values) {\n      return values.map(function (_, index) {\n        return index;\n      });\n    }\n  }, {\n    key: \"getSeries\",\n    value: function getSeries() {\n      var _this$props5 = this.props,\n          data = _this$props5.data,\n          keys = _this$props5.keys,\n          offset = _this$props5.offset,\n          order = _this$props5.order,\n          valueAccessor = _this$props5.valueAccessor;\n      return shape.stack().keys(keys).value(function (item, key) {\n        return valueAccessor({\n          item: item,\n          key: key\n        });\n      }).order(order).offset(offset)(data);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props6 = this.props,\n          data = _this$props6.data,\n          animate = _this$props6.animate,\n          animationDuration = _this$props6.animationDuration,\n          style = _this$props6.style,\n          numberOfTicks = _this$props6.numberOfTicks,\n          children = _this$props6.children,\n          horizontal = _this$props6.horizontal;\n      var _this$state = this.state,\n          height = _this$state.height,\n          width = _this$state.width;\n\n      if (data.length === 0) {\n        return React.createElement(View, {\n          style: style\n        });\n      }\n\n      var series = this.getSeries();\n      var values = array.merge(array.merge(series));\n      var indexes = this.calcIndexes(values);\n      var extent = this.calcExtent(values);\n      var ticks = array.ticks(extent[0], extent[1], numberOfTicks);\n      var xDomain = horizontal ? extent : indexes;\n      var yDomain = horizontal ? indexes : extent;\n      var x = this.calcXScale(xDomain);\n      var y = this.calcYScale(yDomain);\n      var bandwidth = horizontal ? y.bandwidth() : x.bandwidth();\n      var areas = this.calcAreas(x, y, series);\n      var extraProps = {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        ticks: ticks,\n        data: data,\n        bandwidth: bandwidth\n      };\n      return React.createElement(View, {\n        style: style\n      }, React.createElement(View, {\n        style: {\n          flex: 1\n        },\n        onLayout: function onLayout(event) {\n          return _this2._onLayout(event);\n        }\n      }, height > 0 && width > 0 && React.createElement(Svg, {\n        style: {\n          height: height,\n          width: width\n        }\n      }, React.Children.map(children, function (child) {\n        if (child && child.props.belowChart) {\n          return React.cloneElement(child, extraProps);\n        }\n\n        return null;\n      }), areas.map(function (bar, index) {\n        var keyIndex = index % data.length;\n        var key = \"\".concat(keyIndex, \"-\").concat(bar.key);\n        var svg = data[keyIndex][bar.key].svg;\n        return React.createElement(Path, _extends({\n          key: key,\n          fill: bar.color\n        }, svg, {\n          d: bar.path,\n          animate: animate,\n          animationDuration: animationDuration\n        }));\n      }), React.Children.map(children, function (child) {\n        if (child && !child.props.belowChart) {\n          return React.cloneElement(child, extraProps);\n        }\n\n        return null;\n      }))));\n    }\n  }], [{\n    key: \"extractDataPoints\",\n    value: function extractDataPoints(data, keys) {\n      var order = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : shape.stackOrderNone;\n      var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : shape.stackOffsetNone;\n      var series = shape.stack().keys(keys).order(order).offset(offset)(data);\n      return array.merge(array.merge(series));\n    }\n  }]);\n\n  return BarChart;\n}(PureComponent);\n\nBarChart.propTypes = {\n  data: PropTypes.arrayOf(PropTypes.object),\n  keys: PropTypes.arrayOf(PropTypes.string).isRequired,\n  colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n  offset: PropTypes.func,\n  order: PropTypes.func,\n  style: PropTypes.any,\n  spacingInner: PropTypes.number,\n  spacingOuter: PropTypes.number,\n  animate: PropTypes.bool,\n  animationDuration: PropTypes.number,\n  contentInset: PropTypes.shape({\n    top: PropTypes.number,\n    left: PropTypes.number,\n    right: PropTypes.number,\n    bottom: PropTypes.number\n  }),\n  gridMin: PropTypes.number,\n  gridMax: PropTypes.number,\n  valueAccessor: PropTypes.func\n};\nBarChart.defaultProps = {\n  spacingInner: 0.05,\n  spacingOuter: 0.05,\n  offset: shape.stackOffsetNone,\n  order: shape.stackOrderNone,\n  width: 100,\n  height: 100,\n  showZeroAxis: true,\n  contentInset: {},\n  numberOfTicks: 10,\n  showGrid: true,\n  valueAccessor: function valueAccessor(_ref) {\n    var item = _ref.item,\n        key = _ref.key;\n    return item[key];\n  }\n};\nexport default BarChart;","map":{"version":3,"sources":["stacked-bar-chart.js"],"names":["order","shape","offset","series","array","width","height","_onLayout","nativeEvent","layout","calcXScale","data","contentInset","left","right","spacingOuter","scale","calcYScale","top","bottom","calcAreas","keys","path","d","x","_index","y","isNaN","color","colors","key","calcExtent","gridMin","calcIndexes","values","getSeries","valueAccessor","item","render","horizontal","style","indexes","extent","ticks","xDomain","yDomain","bandwidth","areas","extraProps","flex","event","child","React","keyIndex","index","bar","svg","animationDuration","BarChart","PropTypes","spacingInner","animate","number","gridMax","func","showZeroAxis","numberOfTicks","showGrid"],"mappings":"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","sourcesContent":["import * as array from 'd3-array'\nimport * as scale from 'd3-scale'\nimport * as shape from 'd3-shape'\nimport PropTypes from 'prop-types'\nimport React, { PureComponent } from 'react'\nimport { View } from 'react-native'\nimport Svg from 'react-native-svg'\nimport Path from '../animated-path'\n\nclass BarChart extends PureComponent {\n    static extractDataPoints(data, keys, order = shape.stackOrderNone, offset = shape.stackOffsetNone) {\n        const series = shape\n            .stack()\n            .keys(keys)\n            .order(order)\n            .offset(offset)(data)\n\n        //double merge arrays to extract just the values\n        return array.merge(array.merge(series))\n    }\n\n    state = {\n        width: 0,\n        height: 0,\n    }\n\n    _onLayout(event) {\n        const {\n            nativeEvent: {\n                layout: { height, width },\n            },\n        } = event\n        this.setState({ height, width })\n    }\n\n    calcXScale(domain) {\n        const { data } = this.props\n\n        const {\n            horizontal,\n            contentInset: { left = 0, right = 0 },\n            spacingInner,\n            spacingOuter,\n        } = this.props\n\n        const { width } = this.state\n\n        if (horizontal) {\n            return scale\n                .scaleLinear()\n                .domain(domain)\n                .range([left, width - right])\n        }\n\n        // use index as domain identifier instead of value since\n        // domain must be same length as number of bars\n        // same value can occur at several places in data\n        return scale\n            .scaleBand()\n            .domain(data.map((_, index) => index))\n            .range([left, width - right])\n            .paddingInner([spacingInner])\n            .paddingOuter([spacingOuter])\n    }\n\n    calcYScale(domain) {\n        const { data } = this.props\n\n        const {\n            horizontal,\n            contentInset: { top = 0, bottom = 0 },\n            spacingInner,\n            spacingOuter,\n        } = this.props\n\n        const { height } = this.state\n\n        if (horizontal) {\n            return scale\n                .scaleBand()\n                .domain(data.map((_, index) => index))\n                .range([top, height - bottom])\n                .paddingInner([spacingInner])\n                .paddingOuter([spacingOuter])\n        }\n\n        return scale\n            .scaleLinear()\n            .domain(domain)\n            .range([height - bottom, top])\n    }\n\n    calcAreas(x, y, series) {\n        const { horizontal, colors, keys } = this.props\n\n        if (horizontal) {\n            return array.merge(\n                series.map((serie, keyIndex) => {\n                    return serie.map((entry, entryIndex) => {\n                        const path = shape\n                            .area()\n                            .x0((d) => x(d[0]))\n                            .x1((d) => x(d[1]))\n                            .y((d, _index) => (_index === 0 ? y(entryIndex) : y(entryIndex) + y.bandwidth()))\n                            .defined((d) => !isNaN(d[0]) && !isNaN(d[1]))([entry, entry])\n\n                        return {\n                            path,\n                            color: colors[keyIndex],\n                            key: keys[keyIndex],\n                        }\n                    })\n                })\n            )\n        }\n\n        return array.merge(\n            series.map((serie, keyIndex) => {\n                return serie.map((entry, entryIndex) => {\n                    const path = shape\n                        .area()\n                        .y0((d) => y(d[0]))\n                        .y1((d) => y(d[1]))\n                        .x((d, _index) => (_index === 0 ? x(entryIndex) : x(entryIndex) + x.bandwidth()))\n                        .defined((d) => !isNaN(d[0]) && !isNaN(d[1]))([entry, entry])\n\n                    return {\n                        path,\n                        color: colors[keyIndex],\n                        key: keys[keyIndex],\n                    }\n                })\n            })\n        )\n    }\n\n    calcExtent(values) {\n        const { gridMax, gridMin } = this.props\n\n        return array.extent([...values, gridMin, gridMax])\n    }\n\n    calcIndexes(values) {\n        return values.map((_, index) => index)\n    }\n\n    getSeries() {\n        const { data, keys, offset, order, valueAccessor } = this.props\n\n        return shape\n            .stack()\n            .keys(keys)\n            .value((item, key) => valueAccessor({ item, key }))\n            .order(order)\n            .offset(offset)(data)\n    }\n\n    render() {\n        const { data, animate, animationDuration, style, numberOfTicks, children, horizontal } = this.props\n\n        const { height, width } = this.state\n\n        if (data.length === 0) {\n            return <View style={style} />\n        }\n\n        const series = this.getSeries()\n\n        //double merge arrays to extract just the values\n        const values = array.merge(array.merge(series))\n        const indexes = this.calcIndexes(values)\n\n        const extent = this.calcExtent(values)\n        const ticks = array.ticks(extent[0], extent[1], numberOfTicks)\n\n        const xDomain = horizontal ? extent : indexes\n        const yDomain = horizontal ? indexes : extent\n\n        const x = this.calcXScale(xDomain)\n        const y = this.calcYScale(yDomain)\n\n        const bandwidth = horizontal ? y.bandwidth() : x.bandwidth()\n\n        const areas = this.calcAreas(x, y, series)\n\n        const extraProps = {\n            x,\n            y,\n            width,\n            height,\n            ticks,\n            data,\n            bandwidth,\n        }\n\n        return (\n            <View style={style}>\n                <View style={{ flex: 1 }} onLayout={(event) => this._onLayout(event)}>\n                    {height > 0 && width > 0 && (\n                        <Svg style={{ height, width }}>\n                            {React.Children.map(children, (child) => {\n                                if (child && child.props.belowChart) {\n                                    return React.cloneElement(child, extraProps)\n                                }\n                                return null\n                            })}\n                            {areas.map((bar, index) => {\n                                const keyIndex = index % data.length\n                                const key = `${keyIndex}-${bar.key}`\n                                const { svg } = data[keyIndex][bar.key]\n\n                                return (\n                                    <Path\n                                        key={key}\n                                        fill={bar.color}\n                                        {...svg}\n                                        d={bar.path}\n                                        animate={animate}\n                                        animationDuration={animationDuration}\n                                    />\n                                )\n                            })}\n                            {React.Children.map(children, (child) => {\n                                if (child && !child.props.belowChart) {\n                                    return React.cloneElement(child, extraProps)\n                                }\n                                return null\n                            })}\n                        </Svg>\n                    )}\n                </View>\n            </View>\n        )\n    }\n}\n\nBarChart.propTypes = {\n    data: PropTypes.arrayOf(PropTypes.object),\n    keys: PropTypes.arrayOf(PropTypes.string).isRequired,\n    colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n    offset: PropTypes.func,\n    order: PropTypes.func,\n    style: PropTypes.any,\n    spacingInner: PropTypes.number,\n    spacingOuter: PropTypes.number,\n    animate: PropTypes.bool,\n    animationDuration: PropTypes.number,\n    contentInset: PropTypes.shape({\n        top: PropTypes.number,\n        left: PropTypes.number,\n        right: PropTypes.number,\n        bottom: PropTypes.number,\n    }),\n    gridMin: PropTypes.number,\n    gridMax: PropTypes.number,\n    valueAccessor: PropTypes.func,\n}\n\nBarChart.defaultProps = {\n    spacingInner: 0.05,\n    spacingOuter: 0.05,\n    offset: shape.stackOffsetNone,\n    order: shape.stackOrderNone,\n    width: 100,\n    height: 100,\n    showZeroAxis: true,\n    contentInset: {},\n    numberOfTicks: 10,\n    showGrid: true,\n    valueAccessor: ({ item, key }) => item[key],\n}\n\nexport default BarChart\n"]},"metadata":{},"sourceType":"module"}