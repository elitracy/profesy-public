{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport PropTypes from 'prop-types';\nimport * as array from 'd3-array';\nimport * as scale from 'd3-scale';\nimport * as shape from 'd3-shape';\nimport BarChart from \"./bar-chart\";\n\nvar GroupedBarChart = function (_BarChart) {\n  _inherits(GroupedBarChart, _BarChart);\n\n  var _super = _createSuper(GroupedBarChart);\n\n  function GroupedBarChart() {\n    _classCallCheck(this, GroupedBarChart);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(GroupedBarChart, [{\n    key: \"calcXScale\",\n    value: function calcXScale(domain) {\n      var _this$props = this.props,\n          horizontal = _this$props.horizontal,\n          _this$props$contentIn = _this$props.contentInset,\n          _this$props$contentIn2 = _this$props$contentIn.left,\n          left = _this$props$contentIn2 === void 0 ? 0 : _this$props$contentIn2,\n          _this$props$contentIn3 = _this$props$contentIn.right,\n          right = _this$props$contentIn3 === void 0 ? 0 : _this$props$contentIn3,\n          spacingInner = _this$props.spacingInner,\n          spacingOuter = _this$props.spacingOuter,\n          clamp = _this$props.clamp;\n      var width = this.state.width;\n\n      if (horizontal) {\n        return scale.scaleLinear().domain(domain).range([left, width - right]).clamp(clamp);\n      }\n\n      return scale.scaleBand().domain(domain).range([left, width - right]).paddingInner([spacingInner]).paddingOuter([spacingOuter]);\n    }\n  }, {\n    key: \"calcYScale\",\n    value: function calcYScale(domain) {\n      var _this$props2 = this.props,\n          horizontal = _this$props2.horizontal,\n          spacingInner = _this$props2.spacingInner,\n          spacingOuter = _this$props2.spacingOuter,\n          _this$props2$contentI = _this$props2.contentInset,\n          _this$props2$contentI2 = _this$props2$contentI.top,\n          top = _this$props2$contentI2 === void 0 ? 0 : _this$props2$contentI2,\n          _this$props2$contentI3 = _this$props2$contentI.bottom,\n          bottom = _this$props2$contentI3 === void 0 ? 0 : _this$props2$contentI3,\n          clamp = _this$props2.clamp;\n      var height = this.state.height;\n\n      if (horizontal) {\n        return scale.scaleBand().domain(domain).range([top, height - bottom]).paddingInner([spacingInner]).paddingOuter([spacingOuter]);\n      }\n\n      return scale.scaleLinear().domain(domain).range([height - bottom, top]).clamp(clamp);\n    }\n  }, {\n    key: \"calcAreas\",\n    value: function calcAreas(x, y) {\n      var _this$props3 = this.props,\n          horizontal = _this$props3.horizontal,\n          data = _this$props3.data,\n          yAccessor = _this$props3.yAccessor;\n\n      var _data = data.map(function (obj) {\n        var _obj$svg = obj.svg,\n            svg = _obj$svg === void 0 ? {} : _obj$svg;\n        return _objectSpread({}, obj, {\n          data: obj.data.map(function (item) {\n            if (typeof item === 'number') {\n              return {\n                value: item,\n                svg: svg\n              };\n            }\n\n            return _objectSpread({}, item, {\n              svg: _objectSpread({}, svg, {}, item.svg),\n              value: yAccessor({\n                item: item\n              })\n            });\n          })\n        });\n      });\n\n      var areas = [];\n\n      if (horizontal) {\n        var barWidth = y.bandwidth() / data.length;\n\n        _data.forEach(function (obj, collectionIndex) {\n          obj.data.forEach(function (item, valueIndex) {\n            areas.push({\n              bar: item,\n              path: shape.area().y(function (value, _index) {\n                return _index === 0 ? y(valueIndex) + barWidth * collectionIndex : y(valueIndex) + barWidth + barWidth * collectionIndex;\n              }).x0(x(0)).x1(function (value) {\n                return x(value);\n              }).defined(function (value) {\n                return typeof value === 'number';\n              })([item.value, item.value])\n            });\n          });\n        });\n      } else {\n        var _barWidth = x.bandwidth() / data.length;\n\n        _data.forEach(function (obj, collectionIndex) {\n          obj.data.forEach(function (item, valueIndex) {\n            areas.push({\n              bar: item,\n              path: shape.area().x(function (value, _index) {\n                return _index === 0 ? x(valueIndex) + _barWidth * collectionIndex : x(valueIndex) + _barWidth + _barWidth * collectionIndex;\n              }).y0(y(0)).y1(function (value) {\n                return y(value);\n              }).defined(function (value) {\n                return typeof value === 'number';\n              })([item.value, item.value])\n            });\n          });\n        });\n      }\n\n      return areas;\n    }\n  }, {\n    key: \"calcExtent\",\n    value: function calcExtent() {\n      var _this$props4 = this.props,\n          data = _this$props4.data,\n          yAccessor = _this$props4.yAccessor,\n          gridMin = _this$props4.gridMin,\n          gridMax = _this$props4.gridMax;\n      var dataExtent = array.merge(data.map(function (obj) {\n        return obj.data.map(function (item) {\n          return yAccessor({\n            item: item\n          });\n        });\n      }));\n      var extent = array.extent([].concat(_toConsumableArray(dataExtent), [gridMax, gridMin]));\n      var _this$props5 = this.props,\n          _this$props5$yMin = _this$props5.yMin,\n          yMin = _this$props5$yMin === void 0 ? extent[0] : _this$props5$yMin,\n          _this$props5$yMax = _this$props5.yMax,\n          yMax = _this$props5$yMax === void 0 ? extent[1] : _this$props5$yMax;\n      return [yMin, yMax];\n    }\n  }, {\n    key: \"calcIndexes\",\n    value: function calcIndexes() {\n      var data = this.props.data;\n      return data[0].data.map(function (_, index) {\n        return index;\n      });\n    }\n  }]);\n\n  return GroupedBarChart;\n}(BarChart);\n\nGroupedBarChart.propTypes = _objectSpread({}, BarChart.propTypes, {\n  data: PropTypes.arrayOf(PropTypes.shape({\n    data: PropTypes.array.isRequired,\n    svg: PropTypes.object\n  })).isRequired\n});\nexport default GroupedBarChart;","map":{"version":3,"sources":["bar-chart-grouped.js"],"names":["calcXScale","contentInset","left","right","clamp","width","scale","calcYScale","top","bottom","height","calcAreas","yAccessor","_data","obj","svg","data","item","value","areas","barWidth","y","bar","path","shape","_index","x","calcExtent","gridMax","dataExtent","extent","array","yMin","yMax","calcIndexes","GroupedBarChart","BarChart","PropTypes","object","isRequired"],"mappings":"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","sourcesContent":["import PropTypes from 'prop-types'\nimport * as array from 'd3-array'\nimport * as scale from 'd3-scale'\nimport * as shape from 'd3-shape'\nimport BarChart from './bar-chart'\n\nclass GroupedBarChart extends BarChart {\n    calcXScale(domain) {\n        const {\n            horizontal,\n            contentInset: { left = 0, right = 0 },\n            spacingInner,\n            spacingOuter,\n            clamp,\n        } = this.props\n\n        const { width } = this.state\n\n        if (horizontal) {\n            return scale\n                .scaleLinear()\n                .domain(domain)\n                .range([left, width - right])\n                .clamp(clamp)\n        }\n\n        return scale\n            .scaleBand()\n            .domain(domain)\n            .range([left, width - right])\n            .paddingInner([spacingInner])\n            .paddingOuter([spacingOuter])\n    }\n\n    calcYScale(domain) {\n        const {\n            horizontal,\n            spacingInner,\n            spacingOuter,\n            contentInset: { top = 0, bottom = 0 },\n            clamp,\n        } = this.props\n\n        const { height } = this.state\n\n        if (horizontal) {\n            return scale\n                .scaleBand()\n                .domain(domain)\n                .range([top, height - bottom])\n                .paddingInner([spacingInner])\n                .paddingOuter([spacingOuter])\n        }\n\n        return scale\n            .scaleLinear()\n            .domain(domain)\n            .range([height - bottom, top])\n            .clamp(clamp)\n    }\n\n    calcAreas(x, y) {\n        const { horizontal, data, yAccessor } = this.props\n\n        const _data = data.map((obj) => {\n            const { svg = {} } = obj\n            return {\n                ...obj,\n                data: obj.data.map((item) => {\n                    if (typeof item === 'number') {\n                        return {\n                            value: item,\n                            svg,\n                        }\n                    }\n\n                    return {\n                        ...item,\n                        svg: {\n                            ...svg,\n                            ...item.svg,\n                        },\n                        value: yAccessor({ item }),\n                    }\n                }),\n            }\n        })\n\n        const areas = []\n\n        if (horizontal) {\n            const barWidth = y.bandwidth() / data.length\n\n            _data.forEach((obj, collectionIndex) => {\n                obj.data.forEach((item, valueIndex) => {\n                    areas.push({\n                        bar: item,\n                        path: shape\n                            .area()\n                            .y((value, _index) =>\n                                _index === 0\n                                    ? y(valueIndex) + barWidth * collectionIndex\n                                    : y(valueIndex) + barWidth + barWidth * collectionIndex\n                            )\n                            .x0(x(0))\n                            .x1((value) => x(value))\n                            .defined((value) => typeof value === 'number')([item.value, item.value]),\n                    })\n                })\n            })\n        } else {\n            const barWidth = x.bandwidth() / data.length\n\n            _data.forEach((obj, collectionIndex) => {\n                obj.data.forEach((item, valueIndex) => {\n                    areas.push({\n                        bar: item,\n                        path: shape\n                            .area()\n                            .x((value, _index) =>\n                                _index === 0\n                                    ? x(valueIndex) + barWidth * collectionIndex\n                                    : x(valueIndex) + barWidth + barWidth * collectionIndex\n                            )\n                            .y0(y(0))\n                            .y1((value) => y(value))\n                            .defined((value) => typeof value === 'number')([item.value, item.value]),\n                    })\n                })\n            })\n        }\n\n        return areas\n    }\n\n    calcExtent() {\n        const { data, yAccessor, gridMin, gridMax } = this.props\n        const dataExtent = array.merge(data.map((obj) => obj.data.map((item) => yAccessor({ item }))))\n\n        const extent = array.extent([...dataExtent, gridMax, gridMin])\n\n        const { yMin = extent[0], yMax = extent[1] } = this.props\n\n        return [yMin, yMax]\n    }\n\n    calcIndexes() {\n        const { data } = this.props\n        return data[0].data.map((_, index) => index)\n    }\n}\n\nGroupedBarChart.propTypes = {\n    ...BarChart.propTypes,\n    data: PropTypes.arrayOf(\n        PropTypes.shape({\n            data: PropTypes.array.isRequired,\n            svg: PropTypes.object,\n        })\n    ).isRequired,\n}\n\nexport default GroupedBarChart\n"]},"metadata":{},"sourceType":"module"}