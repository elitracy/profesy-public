{"version":3,"sources":["../../src/start/resolveNgrok.ts"],"names":["NGROK_REQUIRED_VERSION","EXPO_DEBUG","getenv","boolish","_ngrokInstance","resolveNgrokAsync","projectRoot","shouldPrompt","autoInstall","ngrok","findNgrokBinAsync","packageName","answer","Prompts","confirmAsync","message","initial","Logger","global","info","chalk","bold","packageManager","PackageManager","createForProject","silent","addGlobalAsync","e","Error","resolvePackageFromProjectAsync","ngrokPackagePath","pkg","require","semver","satisfies","version","ngrokPath","resolveGlobalPackageAsync","requireg","resolve","localInstance","globalInstance"],"mappings":";;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AALA;AAOA,MAAMA,sBAAsB,GAAG,QAA/B;;AACA,MAAMC,UAAU,GAAGC,kBAAOC,OAAP,CAAe,YAAf,EAA6B,KAA7B,CAAnB;;AACA,IAAIC,cAA0B,GAAG,IAAjC;;AAwBO,eAAeC,iBAAf,CACLC,WADK,EAEL;AACEC,EAAAA,YAAY,GAAG,IADjB;AAEEC,EAAAA,WAAW,GAAG;AAFhB,IAGuD,EALlD,EAMS;AACd,QAAMC,KAAK,GAAG,MAAMC,iBAAiB,CAACJ,WAAD,CAArC;;AAEA,MAAI,CAACG,KAAL,EAAY;AACV,UAAME,WAAW,GAAI,eAAcX,sBAAuB,EAA1D;;AACA,QAAIO,YAAJ,EAAkB;AAChB,UAAI,CAACC,WAAL,EAAkB;AAChB;AACA,cAAM,4BAAW,GAAX,CAAN;AACD;;AACD,YAAMI,MAAM,GACVJ,WAAW,KACV,MAAMK,oBAAQC,YAAR,CAAqB;AAC1BC,QAAAA,OAAO,EAAG,eAAcJ,WAAY,qEADV;AAE1BK,QAAAA,OAAO,EAAE;AAFiB,OAArB,CADI,CADb;;AAMA,UAAIJ,MAAJ,EAAY;AACVK,2BAAOC,MAAP,CAAcC,IAAd,CAAoB,cAAaR,WAAY,QAAOS,iBAAMC,IAAK,QAAQ,aAAvE;;AAEA,cAAMC,cAAc,GAAGC,cAAc,GAACC,gBAAf,CAAgClB,WAAhC,EAA6C;AAClEmB,UAAAA,MAAM,EAAE,CAACxB;AADyD,SAA7C,CAAvB;;AAIA,YAAI;AACF,gBAAMqB,cAAc,CAACI,cAAf,CAA8Bf,WAA9B,CAAN;;AACAM,6BAAOC,MAAP,CAAcC,IAAd,CAAoB,0BAAyBR,WAAY,EAAzD;AACD,SAHD,CAGE,OAAOgB,CAAP,EAAU;AACVA,UAAAA,CAAC,CAACZ,OAAF,GAAa,qBAAoBJ,WAAY,cAAagB,CAAC,CAACZ,OAAQ,EAApE;AACA,gBAAMY,CAAN;AACD;;AACD,eAAO,MAAMtB,iBAAiB,CAACC,WAAD,EAAc;AAAEC,UAAAA,YAAY,EAAE;AAAhB,SAAd,CAA9B;AACD;AACF;;AACD,UAAM,IAAIqB,KAAJ,CACH,kBAAiBjB,WAAY,2EAD1B,CAAN;AAGD;;AACD,SAAOF,KAAP;AACD,C,CAED;;;AACA,eAAeoB,8BAAf,CAA8CvB,WAA9C,EAAmE;AACjE,MAAI;AACF,UAAMwB,gBAAgB,GAAG,4BAAYxB,WAAZ,EAAyB,0BAAzB,CAAzB;;AACA,UAAMyB,GAAG,GAAGC,OAAO,CAACF,gBAAD,CAAnB;;AACA,QAAIC,GAAG,IAAIE,kBAAOC,SAAP,CAAiBH,GAAG,CAACI,OAArB,EAA8BnC,sBAA9B,CAAX,EAAkE;AAChE,YAAMoC,SAAS,GAAG,4BAAY9B,WAAZ,EAAyB,aAAzB,CAAlB;;AACA,UAAIL,UAAJ,EAAgB;AACdgB,2BAAOC,MAAP,CAAcC,IAAd,CAAoB,wCAAuCiB,SAAU,GAArE;AACD;;AACD,aAAOJ,OAAO,CAACI,SAAD,CAAd;AACD;AACF,GAVD,CAUE,MAAM,CAAE;;AACV,SAAO,IAAP;AACD,C,CAED;;;AACA,eAAeC,yBAAf,GAA2C;AACzC,MAAI;AACF;AACA,UAAMN,GAAG,GAAG,yBAAS,0BAAT,EAAqC,IAArC,CAAZ;;AACA,QAAIE,kBAAOC,SAAP,CAAiBH,GAAG,CAACI,OAArB,EAA8BnC,sBAA9B,CAAJ,EAA2D;AACzD,UAAIC,UAAJ,EAAgB;AACdgB,2BAAOC,MAAP,CAAcC,IAAd,CACG,uCAAsCmB,oBAASC,OAAT,CAAiB,aAAjB,CAAgC,GADzE;AAGD;;AACD,aAAO,yBAAS,aAAT,EAAwB,IAAxB,CAAP;AACD;AACF,GAXD,CAWE,MAAM,CAAE;;AAEV,SAAO,IAAP;AACD;;AAED,eAAe7B,iBAAf,CAAiCJ,WAAjC,EAAoE;AAClE,MAAIF,cAAJ,EAAoB;AAClB,WAAOA,cAAP;AACD;;AAED,QAAMoC,aAAa,GAAG,MAAMX,8BAA8B,CAACvB,WAAD,CAA1D;;AACA,MAAIkC,aAAJ,EAAmB;AACjBpC,IAAAA,cAAc,GAAGoC,aAAjB;AACA,WAAOpC,cAAP;AACD;;AAED,QAAMqC,cAAc,GAAG,MAAMJ,yBAAyB,EAAtD;;AACA,MAAII,cAAJ,EAAoB;AAClBrC,IAAAA,cAAc,GAAGqC,cAAjB;AACA,WAAOrC,cAAP;AACD;;AAED,SAAO,IAAP;AACD","sourcesContent":["import * as PackageManager from '@expo/package-manager';\nimport chalk from 'chalk';\nimport getenv from 'getenv';\n// @ts-ignore\nimport requireg from 'requireg';\nimport resolveFrom from 'resolve-from';\nimport semver from 'semver';\n\nimport { delayAsync, Logger, Prompts } from '../internal';\n\nconst NGROK_REQUIRED_VERSION = '^4.1.0';\nconst EXPO_DEBUG = getenv.boolish('EXPO_DEBUG', false);\nlet _ngrokInstance: any | null = null;\n\nexport interface NgrokOptions {\n  authtoken?: string;\n  port?: string | number | null;\n  host?: string;\n  httpauth?: string;\n  region?: string;\n  configPath?: string;\n\n  proto?: 'http' | 'tcp' | 'tls';\n  addr?: string;\n  inspect?: boolean;\n  auth?: string;\n  host_header?: string;\n  bind_tls?: true | false | 'both';\n  subdomain?: string;\n  hostname?: string;\n  crt?: string;\n  key?: string;\n  client_cas?: string;\n  remote_addr?: string;\n}\n\nexport async function resolveNgrokAsync(\n  projectRoot: string,\n  {\n    shouldPrompt = true,\n    autoInstall = false,\n  }: { shouldPrompt?: boolean; autoInstall?: boolean } = {}\n): Promise<any> {\n  const ngrok = await findNgrokBinAsync(projectRoot);\n\n  if (!ngrok) {\n    const packageName = `@expo/ngrok@${NGROK_REQUIRED_VERSION}`;\n    if (shouldPrompt) {\n      if (!autoInstall) {\n        // Delay the prompt so it doesn't conflict with other dev tool logs\n        await delayAsync(100);\n      }\n      const answer =\n        autoInstall ||\n        (await Prompts.confirmAsync({\n          message: `The package ${packageName} is required to use tunnels, would you like to install it globally?`,\n          initial: true,\n        }));\n      if (answer) {\n        Logger.global.info(`Installing ${packageName} for ${chalk.bold`tunnel`} support...`);\n\n        const packageManager = PackageManager.createForProject(projectRoot, {\n          silent: !EXPO_DEBUG,\n        });\n\n        try {\n          await packageManager.addGlobalAsync(packageName);\n          Logger.global.info(`Successfully installed ${packageName}`);\n        } catch (e) {\n          e.message = `Failed to install ${packageName} globally: ${e.message}`;\n          throw e;\n        }\n        return await resolveNgrokAsync(projectRoot, { shouldPrompt: false });\n      }\n    }\n    throw new Error(\n      `Please install ${packageName} and try again, or try using another hosting method like lan or localhost`\n    );\n  }\n  return ngrok;\n}\n\n// Resolve a copy that's installed in the project.\nasync function resolvePackageFromProjectAsync(projectRoot: string) {\n  try {\n    const ngrokPackagePath = resolveFrom(projectRoot, '@expo/ngrok/package.json');\n    const pkg = require(ngrokPackagePath);\n    if (pkg && semver.satisfies(pkg.version, NGROK_REQUIRED_VERSION)) {\n      const ngrokPath = resolveFrom(projectRoot, '@expo/ngrok');\n      if (EXPO_DEBUG) {\n        Logger.global.info(`Resolving @expo/ngrok from project: \"${ngrokPath}\"`);\n      }\n      return require(ngrokPath);\n    }\n  } catch {}\n  return null;\n}\n\n// Resolve a copy that's installed globally.\nasync function resolveGlobalPackageAsync() {\n  try {\n    // use true to disable the use of local packages.\n    const pkg = requireg('@expo/ngrok/package.json', true);\n    if (semver.satisfies(pkg.version, NGROK_REQUIRED_VERSION)) {\n      if (EXPO_DEBUG) {\n        Logger.global.info(\n          `Resolving global @expo/ngrok from: \"${requireg.resolve('@expo/ngrok')}\"`\n        );\n      }\n      return requireg('@expo/ngrok', true);\n    }\n  } catch {}\n\n  return null;\n}\n\nasync function findNgrokBinAsync(projectRoot: string): Promise<any> {\n  if (_ngrokInstance) {\n    return _ngrokInstance;\n  }\n\n  const localInstance = await resolvePackageFromProjectAsync(projectRoot);\n  if (localInstance) {\n    _ngrokInstance = localInstance;\n    return _ngrokInstance;\n  }\n\n  const globalInstance = await resolveGlobalPackageAsync();\n  if (globalInstance) {\n    _ngrokInstance = globalInstance;\n    return _ngrokInstance;\n  }\n\n  return null;\n}\n"],"file":"resolveNgrok.js"}